import{_ as e,c as t,o as i,a4 as a,aU as n}from"./chunks/framework.BGFi9fUZ.js";const f=JSON.parse('{"title":"2: Theory","description":"","frontmatter":{},"headers":[],"relativePath":"essentials/du/du-theory.md","filePath":"essentials/du/du-theory.md","lastUpdated":1683562229000}'),o={name:"essentials/du/du-theory.md"},r=a('<h1 id="_2-theory" tabindex="-1">2: Theory <a class="header-anchor" href="#_2-theory" aria-label="Permalink to &quot;2: Theory&quot;">​</a></h1><p><img src="'+n+'" alt="Theory"></p><p>In the development of task-oriented chatbots, dialog understanding (DU) is the process of interpreting user utterances into a structured representation of meaning, in either literal sense or implied sense.</p><p>Given an utterance, the literal meaning is its most obvious meaning, typically it stays constant regardless of context. The implied meaning is the best interpretation under the given context of the conversation, thus can be different under different context, and can be totally different from its literal meaning. For example, upon hearing <em>“I have a meeting in New York City first thing on Tuesday”</em>, a travel agent might infer that user want to get a ticket to New York City, but his secretary might infer that no meeting can be scheduled on Tuesday morning.</p><p>It is clear that the meaning space that DU converts utterances into has a significant impact on the computation model required and downstream dialog management (DM). From this perspective, we will demonstrate that the traditional DU approach based on text classification has its limitations and explain how we can improve upon it.</p><h2 id="intent-classification-crisis" tabindex="-1">Intent Classification Crisis <a class="header-anchor" href="#intent-classification-crisis" aria-label="Permalink to &quot;Intent Classification Crisis&quot;">​</a></h2><p>The current generation of dialog understanding (DU) is based on intent classification, which models the likelihood of an intent given an input utterance in the form of <em>P(intent|utterance)</em>, with intent representing the literal meaning of the utterance. Under this supervised learning formulation, we need a set of labeled data, each with a user utterance mapping to its corresponding intent label. The labeling process is generally laborious, time consuming and expensive.</p><p>High cost is bad, but the real problem is the mismatch between the literal meaning and the implied meaning that is preferred by downstream dialog management (DM) to take action. To illustrate this, consider the following utterance: <em>“My mom is sick”</em>. If your chatbot only sells flowers, you can label it with “buy_flower” intent and ignore its literal meaning. However, when you add a hospital front-desk service, the problem becomes clear: providing only new positive examples for the new service and assuming existing utterances are negative for this service can introduce label errors, which, if left unmanaged, will result in a decrease in accuracy.</p><p>To deal with this properly, it would be necessary to revisit every labeled example whenever a new service is added. The cost of adding a new service would increase linearly with the size of labeled datasets. Unfortunately, this approach is simply not feasible due to dynamic nature of business.</p><h2 id="implicature-calculation" tabindex="-1">Implicature Calculation <a class="header-anchor" href="#implicature-calculation" aria-label="Permalink to &quot;Implicature Calculation&quot;">​</a></h2><p>In his influential paper “Logic and Conversation” (1975), Grice proposed that for individuals to interpret what others say during a conversation, a certain level of cooperation is assumed to be in place. One of the key implication from his well-known cooperative principle pertains to relevance: the speaker’s utterance must be pertinent to the conversation. When there are multiple interpretations of the utterance, the listener should select the interpretation that is most relevant to the conversation.</p><p>The maxim of relevance is is crucial for efficient communication. This gives speakers greater flexibility to construct their utterances with not only their intended meaning but also additional information to speed up the conversation. As an example, Leech (1983: 94) gives the following exchange:</p><p><em>A: Where is my box of chocolates?</em></p><p><em>B: The children were in your room this morning.</em></p><p>The literal meaning of B’s answer here appears not to be relevant to A’s question. But with the assumption that B abides by the cooperative principle it is easy to infer the whereabouts of that box of chocolate. In addition, A might further infer that the children may have eaten the chocolate, which can potentially save a later question <em>“why it is empty now?”</em>.</p><p>The process of listener finding the relevant interpretation for input utterance is called implicature calculation, where implicature is simply the implied meaning. Obviously, implicature calculation is greatly influenced by listener’s context, as well as his world knowledge.</p><h2 id="service-driven-dialog-understanding" tabindex="-1">Service driven dialog understanding <a class="header-anchor" href="#service-driven-dialog-understanding" aria-label="Permalink to &quot;Service driven dialog understanding&quot;">​</a></h2><p>Proper dialog understanding requires the computation of implied meaning based on context. Context includes a linguistic portion, such as conversational history, and a non-linguistic portion, such as business goals and logic, which can be captured by a set of services. Here, a service represents anything that a business does for the user, it can be as large as buying a home and as small as giving a direction.</p><p>Since the goal of chatbot is to provide conversational user interface to a fixed number of services, each triggered by an action, the dialog understanding can be thought as the modeling the probability of each action given the original utterance and context in form of <em>P(action|utterance, context)</em>. Notice this computation model can naturally handle dialog action that DM need to perform when a user says: <em>“Wait, I can not fly on Monday”</em>.</p><p>The design and implementation of DU module should be action (implied meaning) driven instead of intent (literal meaning) driven. This is because:</p><ol><li>Failing to understanding user when they want something out of your service scope will not negatively impact the business’s financial performance. It is OK for a barber shop to reply <em>“Sorry we only cut hair here”</em> to a massage request.</li><li>Compared to the infinite number of legit user intent, the number of services is generally much smaller, even for large corporations. So focusing on actions and modeling whether an utterance imply it can be a lot more manageable.</li><li>Services changes can be simply handled by adding or removing the corresponding actions when we compute the best action given utterance and context, which hold constant for each turn.</li></ol><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p>We have explained that, beyond the conceptual mismatch, intent classification based DU is difficult to fix from a labeling perspective. By tracing back to the theory of conversations, we have shown that DU can be better modeled as implicature calculation onto actions that chatbot can perform on user’s behalf. Early experiments with methods based on large language models are already showing promising results for modeling <em>P(action|utterance, context)</em>, which could greatly simplify the design and implementation of DM.</p><p>Reference:</p><ol><li><a href="https://plato.stanford.edu/entries/implicature/" target="_blank" rel="noreferrer">Stanford implicature entry in their Encyclopedia of Philosophy</a></li><li><a href="https://cobusgreyling.medium.com/rasa-has-intent-deprecation-on-their-roadmap-5b37ce447def" target="_blank" rel="noreferrer">Rasa Has Intent Deprecation On Their Roadmap</a></li></ol>',25),s=[r];function l(c,h,d,m,p,u){return i(),t("div",null,s)}const b=e(o,[["render",l]]);export{f as __pageData,b as default};
