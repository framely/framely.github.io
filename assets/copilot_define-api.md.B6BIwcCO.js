import{_ as t,c as e,o as a,a4 as s}from"./chunks/framework.BGFi9fUZ.js";const g=JSON.parse('{"title":"Implement copilot meta API","description":"","frontmatter":{},"headers":[],"relativePath":"copilot/define-api.md","filePath":"copilot/define-api.md","lastUpdated":1693816797000}'),i={name:"copilot/define-api.md"},n=s(`<h1 id="implement-copilot-meta-api" tabindex="-1">Implement copilot meta API <a class="header-anchor" href="#implement-copilot-meta-api" aria-label="Permalink to &quot;Implement copilot meta API&quot;">​</a></h1><p>Copilot meta API provides ways for copilot client to get the current state of user interaction in JSON, as well as execute actions encoded in JSON. Clearly, the actual definition of state and action and their semantics are application dependent, and need to be designed for the use cases that your copilot try to address. So before starting to develop the copilot, product manager and architect need to work together to design the data structure needed to capture the state of user interaction, as well as a set of actions that your app can execute per user&#39;s request.</p><h2 id="expose-user-interaction-state" tabindex="-1">Expose user interaction state <a class="header-anchor" href="#expose-user-interaction-state" aria-label="Permalink to &quot;Expose user interaction state&quot;">​</a></h2><p>To help user in a context dependent fashion, copilot needs to be aware of the current state of user interaction with your app, and use these states as the context for conversational interaction. Copilot can then suggest different actions for the same command under different contexts, instead of requiring user to provide all the details all the time, thus providing a more natural experience.</p><p>For modern GUI application, the state of user interaction can be represented by a stack of pages, with each page defined by a type, which defines what information it can capture from user, and instance of that type which represent the user input so far on that page. It should be clear that page on top is expanded from a component on the bottom page. In general, the state should simply capture the snapshot of the interaction, instead of the history of it, in order to save the storage need to save them.</p><p>Taking OpenCUI copilot as an example, the context primarily consists of the organization label, agent label, agent type, page label, and so on. For <strong>frontend developers</strong>, you need to implement the context getter function, while <strong>copilot builders</strong> can refer to <a href="./build-copilot.html#build-frame-for-context">building frame for context</a> to learn how to declare the context on the OpenCUI platform.</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;orgLabel&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;me.test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;agentLabel&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;pingpongSL&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;agentType&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;chatbot&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;lang&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;en&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;page&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;typeList&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="support-the-execution-of-actions" tabindex="-1">Support the execution of actions <a class="header-anchor" href="#support-the-execution-of-actions" aria-label="Permalink to &quot;Support the execution of actions&quot;">​</a></h3><p>Upon receiving the user input along with the context that they are in, copilot can provide help in two ways: information and action in form of buttons. The action button captures user intention, and once clicked, will change app state as if users have interacted with app (by mouse clicking and keyboard inputting) in the way that can achieve user&#39;s goal.</p><p>For example, let&#39;s consider OpenCUI platform. If users want to clone a chatbot, they can create a new chatbot by selecting the cloning option, which is an action. Additionally, if the users are not currently on the appropriate page to perform this action, they need to direct to the right page first, which is also an action. For <strong>frontend developers</strong>, you need to implement the action handler function, while <strong>copilot builders</strong> can look up the <a href="https://opencui.io/reference/channels/universalmessage.html#json-representation" target="_blank" rel="noreferrer">universal messages</a> to grasp the basic format of actions. The &quot;actionParams&quot; field in the action date type and the &quot;payload&quot; field in universal messages need to be determined collaboratively between frontend developers and the copilot builders. Taking the previous example into consideration, the &quot;actionParams&quot; (&quot;payload&quot;) field for the clone action can be structured as follows:</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;clickAction&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;custom&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;targetAction&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;action&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;createProject&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;projectType&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;chatbot&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The set of actions your copilot can expose should be supported by your implementation of copilot meta API, and these json objects can be easily generated by copilot backend, and rendered in copilot frontend. Notice copilot frontend only needs to render these actions encoded in JSON, which does not require any understanding of them.</p>`,12),o=[n];function p(r,l,h,c,d,u){return a(),e("div",null,o)}const E=t(i,[["render",p]]);export{g as __pageData,E as default};
