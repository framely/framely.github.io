import{_ as e,c as t,o,a4 as n,aP as i}from"./chunks/framework.BGFi9fUZ.js";const m=JSON.parse('{"title":"Overview","description":"","frontmatter":{},"headers":[],"relativePath":"copilot/overview.md","filePath":"copilot/overview.md","lastUpdated":1693816762000}'),s={name:"copilot/overview.md"},a=n('<h1 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">â€‹</a></h1><p>OpenCUI is a practical framework for building applications with a conversational user interface. At a high level, it adopts a dual-process approach, utilizing Large Language Models (LLMs) to address informational or low-impact queries through prompt engineering. For high-impact and transactional queries, it relies on software engineering. Through the integration of LLM-based dialog understanding and schema-based interaction logic, OpenCUI facilitates cost-effective development of natural and reliable conversational experiences.</p><p>OpenCUI is specially designed to aid in building &#39;copilots,&#39; which function as conversational companions for your existing apps. Unlike regular chatbots that directly trigger backend APIs upon request, copilots provide information and frontend action buttons to guide users through app interactions. This allows you to address existing UX issues without the need to rebuild everything for a conversational user interface. As copilots respond to natural language requests, they eliminate the steep learning curve typically associated with feature-rich applications. Furthermore, copilots offer context-dependent assistance, reducing the effort required for both new and casual users to derive value from your application.</p><div class="info custom-block"><p class="custom-block-title">Life of a copilot query</p><p><img src="'+i+`" alt="How copilot works"></p></div><p>The user query handling process involves the following steps:</p><ol><li>The <strong>user</strong> inputs text to the <strong>copilot frontend</strong>, the <strong>copilot frontend</strong> also query <strong>your app</strong> for the context where users are in your app.</li><li>The <strong>copilot frontend</strong> passes the user query and context to the <strong>copilot backend</strong>.</li><li>Based on the predefined skills, the <strong>copilot backend</strong> responds with relevant text and suggested actions to the <strong>copilot frontend</strong>.</li><li>The <strong>copilot frontend</strong> displays the text and suggested actions to the <strong>user</strong>.</li><li>The <strong>user</strong> clicks a specific suggested action.</li><li>The <strong>app frontend</strong> executes the action requested by the <strong>copilot frontend</strong>.</li><li>The <strong>app frontend</strong> bring user to the target state, saving user from figuring out how to do this.</li></ol><p>Copilot is typically developed using the same client/server architecture: there will be copilot frontend that coexists with your app&#39;s frontend, and then there will be a copilot backend, or simply a special chatbot that you can build using OpenCUI. As conversational companion to your application, copilot needs to interact with your application in order to provide context dependent help to your user. The interaction between the copilot and your application is defined by the following meta API served by your application:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>fun get_state(): List&lt;FrameEvent&gt;  // This function simply return the state in json form.</span></span>
<span class="line"><span>fun execute(action_in_json: Action)  // This function execute the action defined in the json format.</span></span></code></pre></div><p>To build a copilot for your app, you just need to complete the follow two steps:</p><ol><li><strong>Implement copilot meta API in your app</strong>: You need to design the type system to describe the interaction state and frontend action so that user can drive through natural language command.</li><li><strong>Build copilot backend</strong>: This can be done by attaching dialog annotations to function schemas to so that copilot follows the desired interaction logic.</li></ol><p>For most use cases, you can use our reference implementation of copilot frontend (currently only web version) since copilot frontend does not need understand the semantics of copilot meta API. This reference implementation is based on copilot meta API and OpenCUI SDK for interaction with copilot backend. The reference implementation are open sourced so that you can check out in case you need to make modification.</p>`,11),r=[a];function c(l,p,d,u,h,g){return o(),t("div",null,r)}const v=e(s,[["render",c]]);export{m as __pageData,v as default};
